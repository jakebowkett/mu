package main

import (
	"bytes"
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/jakebowkett/go-num/num"
)

const comment = `
/*
	Do not edit this file.

	It is populated by the md2html tool which inserts import
	statements with paths to the generated HTML files prior
	to webpack's compilation to ensure they get bundled and
	have content hashes generated for each. The alternative
	would be manually updating the imports as the files changed.

	Development builds will include imports to .md files to
	ensure that the filewatcher will watch them and re-build
	on changes.
*/
`

// Write imports to .tsx file.
func webpackImports(
	src string,
	prefix string,
	tsxFile string,
	mode string,
	seen map[string]string,
) error {

	buf := bytes.Buffer{}
	buf.WriteString(strings.TrimSpace(comment))

	// Ensure consistent ordering to make human reading easier.
	var ids []string
	for id := range seen {
		ids = append(ids, id)
	}
	sort.Strings(ids)

	if mode == "development" {
		for _, id := range ids {
			buf.WriteString(fmt.Sprintf(
				"\nimport %q;",
				"./"+seen[id],
			))
		}
	}

	mapping := make(map[string]string)
	for i, id := range ids {
		a, _ := num.Alpha(i)
		mapping[id] = a
		buf.WriteString(fmt.Sprintf(
			"\nimport %s from %q;",
			a,
			prefix+id+".html",
		))
	}
	buf.WriteString("\nconst CONTENT_MAPPING: {[index: string]: string} = {};")
	for _, id := range ids {
		buf.WriteString(fmt.Sprintf(
			"\nCONTENT_MAPPING[%q] = %s;",
			id,
			mapping[id],
		))
	}
	buf.WriteString("\nexport default CONTENT_MAPPING;")
	importFilePath := filepath.Join(src, tsxFile)
	return writeIfUnique(importFilePath, buf.Bytes())
}

func writeIfUnique(dst string, data []byte) error {
	_, err := os.Stat(dst)
	switch {
	// File does not exist.
	case errors.Is(err, fs.ErrNotExist):
		break
	// An error we can't handle.
	case err != nil:
		return err
	// File exists.
	default:
		fileOnDisk, err := os.ReadFile(dst)
		if err != nil {
			return err
		}
		/*
			If the file is the same as what we are about to
			write abort here. This prevents the webpack dev
			server from getting in an infinite loop of where
			the file is updated which triggers a rebuild that
			updates the file once more trigging another build.
		*/
		if bytes.Equal(fileOnDisk, data) {
			return nil
		}
	}
	return os.WriteFile(dst, data, 0600)

}
